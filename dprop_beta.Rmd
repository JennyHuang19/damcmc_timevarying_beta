---
title: "dprop_beta"
author: "Jenny Yijian Huang"
date: "11/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Helper functions for computing the MH ratio.

### A. Evaluating the prior.

# P(dbeta)
```{r}
#' EVALUATE PRIOR DENSITY OF DBETA (LOG SPACE: SUM OF BERN.)
#'
#' @param dbeta delta beta vector (current)
#' @param prob prior for P(dbeta_i = 1)
#'
#' @return the prior density evaluated at dbeta
#' @export
#'
prior_dbeta <- function(prob, dbeta){
  total_prob <- 0
  for(i in 1:length(dbeta)){
    if(dbeta[i] == 0){
      total_prob <- total_prob + log(prob[i]) # h_i = p(dbeta_i = 0)
    }
    else{
      total_prob <- total_prob + log(1-prob[i])
    }
  }
  return(total_prob)
}
```

```{r}
dbeta_j <- c(0,0,0)
prob <- c(.01,.01,.01)
prior_dbeta(prob, dbeta_j)
```

# P(beta | dbeta)

```{r}
#' EVALUATE PRIOR DENSITY OF BETA (PRODUCT OF GAMMA DENSITIES)
#'
#' @param beta_star beta vector (current)
#' @param par_prior parameters of the prior distributions
#'
#' @return the prior density evaluated at beta_star
#' @export
#'
prior_beta <- function(beta_star, par_prior){
  # EVALUATE PRIOR DENSITY OF BETA (PRODUCT OF GAMMA DENSITIES)
  # beta_star is the vector of betas returned by draw_beta
  
  # evaluate f_beta on the first segment. 
  f_beta <- stats::dgamma(beta_star[1], par_prior['a_beta'][[1]], par_prior['b_beta'][[1]], log = TRUE)
  
  # evaluate f_beta on each of the subsequent segments.
  for(i in 2:length(beta_star)){
    if(beta_star[i] != beta_star[i-1]){
      f_beta <- f_beta + stats::dgamma(beta_star[i], par_prior['a_beta'][[1]], par_prior['b_beta'][[1]], log = TRUE)
    }
    
  }
return(f_beta)
}
```


### B. Evaluating the proposal distribution.

```{r}
prob <- c(0.9, 0.9, 0.9, 0.8, 0.9, 0.9)
dbeta_j <- c(0,0,0,1,0,0)

dbeta_star <- draw_dbeta(prob, dbeta_j)
dbeta_star
```

# P(dbeta_star | dbeta)
```{r}
#' EVALUATE PROPOSAL DENSITY OF DBETA (DBETA IS DRAWN FROM A UNIFORM DISTRIBUTION)
#'
#' @param dbeta delta beta vector (current)
#'
#' @return the proposal density evaluated at dbeta
#' @export
#'
f_dbeta_func <- function(dbeta) {
  prob_dbeta <- 1/length(dbeta) # uniform distribution.
  return(log(prob_dbeta))
}
```

```{r}
f_dbeta_star <- f_dbeta_func(dbeta_j)
f_dbeta_star
```

# P(beta | dbeta_star, Z)
```{r}
#' EVALUATE PROPOSAL DENSITY OF BETA (PRODUCT OF GAMMA DENSITIES)
#'
#' @param beta_star beta vector (current)
#' @param par_prior parameters of the prior distributions
#' @param segmented_SS sufficient statistics of the current configuration of the latent data
#'
#' @return the proposal density evaluated at beta_star.
#' @export
#'
f_beta_func <- function(beta_star, par_prior, segmented_SS){
  # EVALUATE PROPOSAL DENSITY OF BETA (PRODUCT OF GAMMA DENSITIES)
  # beta_star is the vector of betas returned by draw_beta
  
  # evaluate f_beta on the first segment. 
  f_beta <- stats::dgamma(beta_star[1], par_prior['a_beta'][[1]] + segmented_SS[[1]]$n_T, par_prior['b_beta'][[1]] + segmented_SS[[1]]$integral_SI, log = TRUE)
  
  # case when there is only 1 segment
  if(length(beta_star) == 1) return(f_beta)
  
  # evaluate f_beta on each of the subsequent segments.
  for(i in 2:length(beta_star)){
    if(beta_star[i] != beta_star[i-1]){
      f_beta <- f_beta + stats::dgamma(beta_star[i], par_prior['a_beta'][[1]] + segmented_SS[[i]]$n_T, par_prior['b_beta'][[1]] + segmented_SS[[i]]$integral_SI, log = TRUE)
    }
    
  }
return(f_beta)
}
```


# log P(delta) + log P(beta| delta, Z)
```{r}
f_dbeta_beta <- f_dbeta + f_beta
f_dbeta_beta
```


