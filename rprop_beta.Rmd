---
title: "rprop_beta"
author: "Jenny Yijian Huang"
date: "11/2/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Helper functions for proposing new values for (dbeta, beta).

Note: Each vector component in beta_star and beta represents a time unit (e.g. a week)

Illustration of how the indexing works:

dbeta [beta_0-to-1, beta_1-to-2, ...beta_(n-1)-to-n]
beta [beta_0, beta_1, ...beta_n]


# draw from (dbeta_star | dbeta)
```{r}
#' Propose a new delta beta through flipping 1 component of the current dbeta vector at random.
#'
#' @param dbeta delta beta vector (current)
#'
#' @return new draw of dbeta
#' @export
#'
draw_dbeta <- function(dbeta) {
  
  # Function to flip randomly 1 component in the dbeta vector.
  u <- sample(1:length(dbeta), 1)
  
  if(dbeta[u] == 1){
    dbeta[u] <- 0
  }
  else{
    dbeta[u] <- 1
  }
  return(dbeta)
}
```


# if we would like to flip according to a prior probability vector, we can do that using is_prob = TRUE.
#if(is_prop){
# changed_dbeta <- rbern(1, prob[u])
# dbeta[u] <- changed_dbeta
#}

```{r}
# example
dbeta_j <- c(0,0,0,1,0,0)

dbeta_star <- draw_dbeta(dbeta_j)
dbeta_star
```


# draw from (beta | dbeta_star, Z)
```{r}
#' Propose a new beta vector using gibbs_theta conditional on the location of change points (dbeta) and data.
#'
#' @inheritParams b_gibbs_theta
#' @param dbeta_star delta beta vector (current)
#' @param segmented_SS sufficient statistics of the current configuration of the latent data

#' @return new draw of beta
#' @export
#'
draw_beta <- function(dbeta_star, segmented_SS, iota_dist, gamma=1, par_prior, param, Y){
  
  # Function to draw a beta vector given the sufficient statistics and locations of the change-points.

  # 1. initialize beta_star
  beta_star <- c()
  
  # 2. calculate beta for the first segment.
  segment_number = 1
  beta_i <- b_gibbs_theta(segmented_SS[[segment_number]],  iota_dist="exponential", gamma=1, par_prior, param, Y)
  beta_star <- append(beta_star, beta_i)
  
  # 3. calculate beta for each subsequent segment.
  for (i in 1:length(dbeta_star)) {
    # print(i)
    if(dbeta_star[i] == 1){ # calculate beta_i where the dbeta vector indicates a change-point.
      segment_number = segment_number + 1
      beta_i <- b_gibbs_theta(segmented_SS[[segment_number]], iota_dist="exponential", gamma=1, par_prior, param, Y)
      beta_star <- append(beta_star, beta_i)
    }
    else{ # append the previous week's beta_i
      beta_star <- append(beta_star, beta_i)
    }
  }
  return(beta_star)
}
```

# example draw_beta
```{r}
segment_start = c(0, 1, 4)
segment_end = c(1, 4, 6)
dbeta_star <- c(1,0,0,1,0) # CORRECT: (week 1->2).
```

```{r}
# 1. determine the change-point locations.
segment_start <- c(0) # 0 the time marking the start of segment one.
segment_start <- append(segment_start, which(dbeta_star == 1)) # append all locations where dbeta == 1. These will be additional start locations.

segment_end <- c(Y[["t_end"]]) # t_end will marks the end of time.
segment_end <- append(which(dbeta_star == 1), segment_end) # These will be additional end locations.

# 2. calculate sufficient statistics using the start and end points calculated. segmented_SS contains the suff_stats for each segment.
segmented_SS <- suff_stat2(segment_start, segment_end, x, Y, gener, b, return_SI = FALSE)
```

```{r}
beta_new <- draw_beta(dbeta_new, segmented_SS[[segment_number]],  iota_dist="exponential", gamma=1, par_prior, param, Y)
beta_new
```











