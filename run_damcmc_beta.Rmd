---
title: "run_damcmc_beta"
author: "Jenny Yijian Huang"
date: "12/17/2021"
output: html_document
---

# First Attempt at Full DA-MCMC
# Updated Dec. 22nd: Fixed acceptance ratio bug. The Rmd titled h_hat_flexible has the most recent implementation of run_DAMCMC_beta.
```{r}
run_DAMCMC_beta <- function(
  x, Y, N = 10000,
  rho = 1, param = "bg", approx = "ldp",
  iota_dist = "exponential", gener = FALSE, b = 1/2,
  thin = 100,
  par_prior = list(
    a_beta = 0.01, b_beta = 1,
    a_gamma = 1, b_gamma = 1,
    a_R0 = 2, b_R0 = 2,
    a_lambda = 1, b_lambda = 1
  ),
  h_hat = c(0.75,0.75,0.75,0.75,0.75) # P(dbeta_i = 0)
) {
  
    # Setup
    b_f_save <- numeric(N / thin)
    b_accept <- numeric(N) # T/F whether the iteration accepts the proposal
    dbeta_save <- numeric(N / thin)
    beta_save <- numeric(N / thin)
    
    acc_b_f_save <- c()
    acc_dbeta_save <- c()
    acc_beta_save <- c()
    
    

    # Setting Z as the true epidemic path for now.
    x_current <- x
    
    # init proposal
    # 1. Propose dbeta
    dbeta_current <- rbern(length(h_hat), (1-h_hat))
    
    dbeta_save[1] <- list(dbeta_current)

    # 2. determine the change-point locations.
    segment_start <- c(0) # time marking the start of segment one.
    segment_start <- append(segment_start, which(dbeta_current == 1)) # append all locations where dbeta == 1. These will be additional start locations.
    segment_end <- c(Y[["t_end"]]) # t_end will marks the end of time.
    segment_end <- append(which(dbeta_current == 1), segment_end) # here are the additional end locations.

    # 3. calculate sufficient statistics for z using the start and end points calculated. segmented_SS is suff. statistics for each segment.
    segmented_SS_current <- suff_stat2(segment_start, segment_end, x_current, Y, gener, b, return_SI = FALSE)

    # 4. Propose (beta | dbeta)
    beta_current <- draw_beta(dbeta_current, segmented_SS_current, iota_dist, gamma=1, par_prior, param, Y)
    beta_save[1] <- list(beta_current)
    
    
    # current log likelihood
    unique_beta_current <- unique(beta_current)
    b_target_current     <- 0 # -2591.426
    
    for(i in 1:length(unique_beta_current)){
      if(i != length(unique_beta_current)){
        b_target_current <- b_target_current + b_f_log(unique_beta_current[i], gamma=1, segmented_SS_current[[i]], gener, b, iota_dist = "exponential")
      }
      else{ # for the last segment alone, b_f_log accounts for iota_infectious.
        b_target_current <- b_target_current + b_f_log_last(unique_beta_current[i], gamma=1, segmented_SS_current[[i]], gener, b, iota_dist = "exponential")
      }
    } # using iota_inf = -2557.233.  without iota_inf = -2397.379.


    # MH
    for(s in 2 : N) {

      # Update theta (Gibbs)
      # theta <- gibbs_theta(SS_current, iota_dist, par_prior, theta, param, Y)
      
      # Propose (dbeta, beta | Z) ###########
      # 1. Propose dbeta
      dbeta_new <- draw_dbeta(dbeta_current)

      # 2. determine the change-point locations.
      segment_start <- c(0) 
      segment_start <- append(segment_start, which(dbeta_new == 1))
      segment_end <- c(Y[["t_end"]])
      segment_end <- append(which(dbeta_new == 1), segment_end)

      # 3. calculate sufficient statistics for Z using the start and end points.
      segmented_SS_new <- suff_stat2(segment_start, segment_end, x_current, Y, gener, b, return_SI = FALSE)
  
      # 4. Propose (beta | dbeta)
      beta_new <- draw_beta(dbeta_new, segmented_SS_new, iota_dist, gamma=1, par_prior, param, Y)

      # 5. Compute the Ratio.
      unique_beta_current <- unique(beta_current)
      
      unique_beta_new <- unique(beta_new)
      
      # Target density
      b_target_new <- 0
      for(i in 1:length(unique_beta_new)){
          if(i != length(unique_beta_new)){
            b_target_new <- b_target_new + b_f_log(unique_beta_new[i], gamma=1, segmented_SS_new[[i]], gener, b, iota_dist = "exponential")
          }
          else{ # for the last segment alone, b_f_log accounts for iota_infectious.
            b_target_new <- b_target_new + b_f_log_last(unique_beta_new[i], gamma=1, segmented_SS_new[[i]], gener, b, iota_dist = "exponential")
          }
      }
      
      # Proposal density 
      b_prop_current <- f_dbeta_func(dbeta_current) + f_beta_func(unique_beta_current, par_prior, segmented_SS_current) # 6.654678
      b_prop_new <- f_dbeta_func(dbeta_new) + f_beta_func(unique_beta_new, par_prior, segmented_SS_new) # 14.02629
    
      # Priors
      b_prior_current <- prior_dbeta(h_hat, dbeta_current) + prior_beta(beta_current, par_prior) # 0.8282472
      b_prior_new <- prior_dbeta(h_hat, dbeta_new) + prior_beta(beta_new, par_prior) # -0.05665495
      
      # MH ratio
      b_R_log <- b_prior_new - b_prior_current + b_target_new - b_target_current + b_prop_current - b_prop_new
      b_R         <- min(1, exp(b_R_log))
      b_accept[s] <- stats::runif(1) < b_R
      
      if(s %% 1000 == 0){
          print("Acceptance Ratio")
          print(b_R)
      }
      
      
      # Save thinned draws
      if(s %% thin == 0){
        j <- s / thin
        b_f_save[j] <- b_target_new
        dbeta_save[j] <- list(dbeta_new)
        beta_save[j] <- list(beta_new)
      }
      
      
      # Accept/reject new draws
      if(b_accept[s]) {
          print("iteration accepted!")

          print(s)
          print(dbeta_new)
          print(beta_new)
          
          # save proposed values.
          dbeta_current <- dbeta_new
          beta_current        <- beta_new
          b_target_current <- b_target_new
          segmented_SS_current <- segmented_SS_new 
          
          # save accepted values.
          acc_b_f_save <- c(acc_b_f_save, b_target_new)
          acc_dbeta_save <- c(acc_dbeta_save, list(dbeta_new))
          acc_beta_save <- c(acc_beta_save, list(beta_new))
          
      } # end-if
      
      ##############
      
      ##############
      # Propose (Z | dbeta, beta) ######## (keeping it constant for now.)
      #x_new    <- rprop_x(theta, Y, gener, b, iota_dist, approx, x_current, rho)
      x_new <- x_current
      ##############

  } # end-for

  # Output
  out <- list(
    acc_loglik = acc_b_f_save, acc_dbeta_lst = acc_dbeta_save, acc_beta_lst = acc_beta_save,
    dbeta_lst = dbeta_save, beta_lst = beta_save, loglik = b_f_save, theta_rate_accept = mean(b_accept)
  )
  
  return(out)
  }
```


```{r }
# simulate an epidemic and observed data: x and Y

practice_x <- simulate_SEM(
  S0 = 1e3, I0 = 1e1, t_end = 6,
  theta = list(R0 = 2.5, gamma = 1, lambda = 1, shape = 1),
  iota_dist = "exponential", # "weibull"
  gener = FALSE, b = 1/2,
  E0 = 0, type = "SIR"
)
# beta  <- R0 / gamma / S0

x <- practice_x$x
Y <- observed_data(practice_x, K)
```


```{r}
# Sample Run
sample_run <- run_DAMCMC_beta(
  x, Y, N = 10000,
  rho = 1, param = "bg", approx = "ldp",
  iota_dist = "exponential", gener = FALSE, b = 1/2,
  thin = 10,
  par_prior = list(
    a_beta = 0.01, b_beta = 1,
    a_gamma = 1, b_gamma = 1,
    a_R0 = 2, b_R0 = 2,
    a_lambda = 1, b_lambda = 1
  ),
  h_hat = c(0.9,0.9,0.9,0.9,0.9) # P(dbeta_i = 0)
)
```


MCMC Diagnostics

```{r}
# acceptance rate
sample_run$theta_rate_accept
# sample values of beta
sample_run$beta_lst[90:100]
```

```{r}
# Change output into a df
b_lst <- sample_run$beta_lst
b_matrix <- do.call(rbind, b_lst)
b_df <- data.frame(b_matrix)
```

Trace Plots:

```{r}
library('coda') # http://sbfnk.github.io/mfiidd/mcmc_diagnostics.html
mcmc.trace <- mcmc(b_df)
summary(mcmc.trace)
```

Each Xi corresponds to one component in the beta vector.

```{r}
plot(mcmc.trace) # recording new_beta each iteration (whether beta is accepted or not)
```
Autocorrelation Plot:

```{r}
autocorr.plot(mcmc.trace)
```

Code for changing latent path (Later):

# Propose (Z | dbeta, beta)
```{r}
# Propose (Z | dbeta, beta)
  
      # Propose latent space (keeping it constant for now.)
      #x_new    <- rprop_x(theta, Y, gener, b, iota_dist, approx, x_current, rho)
      x_new <- x_current
      #SS_new   <- suff_stat(x_new, Y, gener, b)
      SS_new <- SS_current
      i_update <- x_new[["i_update"]]
  
      # If x_new incompatible with observed data Y
      # NA
      
  
  
      # Target density
      f_target_current <- f_log(theta, SS_current, gener, b, iota_dist)
      f_target_new     <- f_log(theta, SS_new    , gener, b, iota_dist)
  
      # Proposal density
      f_prop_current <- dprop_x(theta, Y, x_current, i_update, gener, b, iota_dist, approx)
      f_prop_new     <- dprop_x(theta, Y, x_new    , i_update, gener, b, iota_dist, approx)
  
      # MH ratio
      R_log     <- f_target_new - f_target_current - f_prop_new + f_prop_current
      R         <- min(1, exp(R_log))
      accept[i] <- stats::runif(1) < R
  
      # Accept/reject new draws
      if(accept[i]) {
        if(print_i)  print(i)
        x_current        <- x_new
        f_target_current <- f_target_new
        SS_current       <- SS_new
      } # end-if
  
      # Save thinned draws
      if(i %% thin == 0) {
        j <- i / thin
        theta_save[[j]] <- theta
        if(save_SS)  SS_save[[j]] <- SS_current
        f_save    [[j]] <- f_target_current
      }
```
