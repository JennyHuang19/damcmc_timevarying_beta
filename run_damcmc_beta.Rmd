---
title: "run_damcmc_beta"
author: "Jenny Yijian Huang"
date: "12/17/2021"
output: html_document
---

Questions:
0. Is the starting location for theta affecting the chain? (is starting out exactly on target affecting/lowering acceptance rates?)
1. Why are the acceptance ratios so low? Why is the likelihood term large in magnitude and negative? Hence, the difference in likelihood terms is dominating the ratio. (why are the likelihood values so low -2500s even when we are using the true values for beta, gamma). Is it valid to re-weight the likelihood and the proposal distribution in the MH ratio?
4. f_beta: spiky/strange gamma distribution. Read up on gamma distributions.
5. Read up on MH: what is detailed balance?

Notes:
0. I separated theta into beta_i and gamma in several places. (f_log, gibbs_theta).
1. I renamed several helper functions with "b" in front to indicate modifications for accommodating a piecewise beta.

# simulate an epidemic and observed data: x and Y
```{r }
my_x <- simulate_SEM(
  S0 = 1e3, I0 = 1e1, t_end = 6,
  theta = list(R0 = 2.5, gamma = 1, lambda = 1, shape = 1),
  iota_dist = "exponential", # "weibull"
  gener = FALSE, b = 1/2,
  E0 = 0, type = "SIR"
)
# beta  <- R0 / gamma / S0

x <- my_x$x
Y <- observed_data(A_x, K)
```

```{r}
sample_run <- run_DAMCMC_beta(
  Y, N = 5000,
  rho = 1, param = "bg", approx = "ldp",
  iota_dist = "exponential", gener = FALSE, b = 1/2,
  thin = 10,
  par_prior = list(
    a_beta = 0.01, b_beta = 1,
    a_gamma = 1, b_gamma = 1,
    a_R0 = 2, b_R0 = 2,
    a_lambda = 1, b_lambda = 1
  ),
  h_hat = c(0.9,0.9,0.9,0.9,0.9) # P(dbeta_i = 0)
)
```

# DA-MCMC
```{r}
run_DAMCMC_beta <- function(
  Y, N = 1000,
  rho = 1, param = "bg", approx = "ldp",
  iota_dist = "exponential", gener = FALSE, b = 1/2,
  thin = 100,
  par_prior = list(
    a_beta = 0.01, b_beta = 1,
    a_gamma = 1, b_gamma = 1,
    a_R0 = 2, b_R0 = 2,
    a_lambda = 1, b_lambda = 1
  ),
  h_hat = c(0.75,0.75,0.75,0.75,0.75) # P(dbeta_i = 0)
) {
  
    # Setup
    b_f_save <- numeric(N / thin)
    b_accept <- numeric(N) # T/F whether the iteration accepts the proposal
    dbeta_save <- numeric(N / thin)
    beta_save <- numeric(N / thin)
    
    
    # theta_0 <- complete_theta(theta_0, iota_dist, Y[["S0"]])
    # theta_save[[1]] <- theta <- theta_0 # theta
    

    # Setting Z as the true epidemic path for now.
    x_current <- x
    
    # init proposal
    # 1. Propose dbeta
    dbeta_current <- rbern(length(h_hat), (1-h_hat))
    dbeta_save[1] <- list(dbeta_current)
    
    # 2. determine the change-point locations.
    segment_start <- c(0) # time marking the start of segment one.
    segment_start <- append(segment_start, which(dbeta_current == 1)) # append all locations where dbeta == 1. These will be additional start locations.
    segment_end <- c(Y[["t_end"]]) # t_end will marks the end of time.
    segment_end <- append(which(dbeta_current == 1), segment_end) # here are the additional end locations.
    
    # 3. calculate sufficient statistics for z using the start and end points calculated. segmented_SS is suff. statistics for each segment.
    segmented_SS_current <- suff_stat2(segment_start, segment_end, x_current, Y, gener, b, return_SI = FALSE)

    # 4. Propose (beta | dbeta)
    beta_current <- draw_beta(dbeta_current, segmented_SS_current, iota_dist, gamma=1, par_prior, param, Y)
    beta_save[1] <- list(beta_current)

    # MH
    for(s in 2 : N) {

      # Update theta (Gibbs)
      # theta <- gibbs_theta(SS_current, iota_dist, par_prior, theta, param, Y)
      
      # Propose (dbeta, beta | Z) ###########
      # 1. Propose dbeta
      dbeta_new <- draw_dbeta(dbeta_current)
      
      # 2. determine the change-point locations.
      segment_start <- c(0) 
      segment_start <- append(segment_start, which(dbeta_new == 1))
      segment_end <- c(Y[["t_end"]])
      segment_end <- append(which(dbeta_new == 1), segment_end)
      
      # 3. calculate sufficient statistics for z using the start and end points calculated.
      segmented_SS_new <- suff_stat2(segment_start, segment_end, x_current, Y, gener, b, return_SI = FALSE)
  
      # 4. Propose (beta | dbeta)
      beta_new <- draw_beta(dbeta_new, segmented_SS_new, iota_dist, gamma=1, par_prior, param, Y)

      # 5. Compute the Ratio.
      unique_beta_current <- unique(beta_current)
      unique_beta_new <- unique(beta_new)
      
      # Target density
      b_target_curr     <- 0 # -2591.426
      for(i in 1:length(unique_beta_current)){
          b_target_curr <- b_target_curr + b_f_log(unique_beta_current[i], gamma=1, segmented_SS_current[[i]], gener, b, iota_dist = "exponential")
      }
      b_target_new <- 0 # -2790.02
      for(i in 1:length(unique_beta_new)){
          b_target_new <- b_target_new + b_f_log(unique_beta_new[i], gamma=1, segmented_SS_new[[i]], gener, b, iota_dist = "exponential")
      }
      
      # Proposal density 
      b_prop_current <- f_dbeta_func(dbeta_current) + f_beta_func(unique_beta_current, par_prior, segmented_SS_current) # 6.654678
      b_prop_new <- f_dbeta_func(dbeta_new) + f_beta_func(unique_beta_new, par_prior, segmented_SS_new) # 14.02629
    
      # Priors
      b_prior_current <- prior_dbeta(h_hat, dbeta_current) + prior_beta(beta_current, par_prior) # 0.8282472
      b_prior_new <- prior_dbeta(h_hat, dbeta_new) + prior_beta(beta_new, par_prior) # -0.05665495
      
      # MH ratio
      b_R_log <- b_prior_new - b_prior_current + (1/50)*b_target_new - (1/50)*b_target_curr + b_prop_current - b_prop_new
      b_R         <- min(1, exp(b_R_log))
      b_accept[s] <- stats::runif(1) < b_R
      
      if(s %% 100 == 0){
          print("Acceptance Ratio")
          print(b_R)
      }
      
      
      # Save thinned draws
      if(s %% thin == 0){
        j <- s / thin
        b_f_save[j] <- b_target_new
        dbeta_save[j] <- list(dbeta_new)
        beta_save[j] <- list(beta_new)
      }
      
      
      # Accept/reject new draws
      if(b_accept[s]) {
          print("iteration accepted!")

          print(s)
          
          dbeta_current          <- dbeta_new
          beta_current        <- beta_new
          b_target_current <- b_target_new
          segmented_SS_current <- segmented_SS_new 
      } # end-if
      ##############
      
      ##############
      # Propose (Z | dbeta, beta) ######## (keeping it constant for now.)
      #x_new    <- rprop_x(theta, Y, gener, b, iota_dist, approx, x_current, rho)
      x_new <- x_current
      ##############


  } # end-for

  # Output
  out <- list(
    dbeta_lst = dbeta_save, beta_lst = beta_save, loglik = b_f_save, theta_rate_accept = mean(b_accept)
  )
  
  return(out)
  }
```

# Propose (Z | dbeta, beta)
```{r}
# Propose (Z | dbeta, beta)
  
      # Propose latent space (keeping it constant for now.)
      #x_new    <- rprop_x(theta, Y, gener, b, iota_dist, approx, x_current, rho)
      x_new <- x_current
      #SS_new   <- suff_stat(x_new, Y, gener, b)
      SS_new <- SS_current
      i_update <- x_new[["i_update"]]
  
      # If x_new incompatible with observed data Y
      # NA
      
  
  
      # Target density
      f_target_current <- f_log(theta, SS_current, gener, b, iota_dist)
      f_target_new     <- f_log(theta, SS_new    , gener, b, iota_dist)
  
      # Proposal density
      f_prop_current <- dprop_x(theta, Y, x_current, i_update, gener, b, iota_dist, approx)
      f_prop_new     <- dprop_x(theta, Y, x_new    , i_update, gener, b, iota_dist, approx)
  
      # MH ratio
      R_log     <- f_target_new - f_target_current - f_prop_new + f_prop_current
      R         <- min(1, exp(R_log))
      accept[i] <- stats::runif(1) < R
  
      # Accept/reject new draws
      if(accept[i]) {
        if(print_i)  print(i)
        x_current        <- x_new
        f_target_current <- f_target_new
        SS_current       <- SS_new
      } # end-if
  
      # Save thinned draws
      if(i %% thin == 0) {
        j <- i / thin
        theta_save[[j]] <- theta
        if(save_SS)  SS_save[[j]] <- SS_current
        f_save    [[j]] <- f_target_current
      }
```

```{r}
# acceptance rate
sample_run$theta_rate_accept
sample_run$beta_lst[90:100]
```

```{r}
# Change output into a df
b_lst <- sample_run$beta_lst
b_matrix <- do.call(rbind, b_lst)
b_df <- data.frame(b_matrix)
```

# MCMC Trace Plots:
http://sbfnk.github.io/mfiidd/mcmc_diagnostics.html
```{r}
library('coda')
mcmc.trace <- mcmc(b_df)
summary(mcmc.trace)
```

Each Xi corresponds to a component in the beta vector.

```{r}
plot(mcmc.trace) # recording new_beta each iteration (whether beta is accepted or not)
```

```{r}
autocorr.plot(mcmc.trace)
```

