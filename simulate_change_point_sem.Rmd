---
title: 'simulate_change_point_sem'
author: "Jenny Yijian Huang"
date: "11/9/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
#' Simulation of an SEM using Gillespie's algorithm to propose wait times and types of events. Beta is a piecewise constant.
#'
#'
#' @inheritParams experiment_1_proof_of_concept
#'
#' @param E0 intial exposed population size
#' @param type c("SIR", "SEIR"); type of process to simulate
#'
#' @return a list with all types of useful objects
#' @export
#'
simulate_change_point_SEM <- function(
  S0 = 1e3, I0 = 1e1, t_end = 6,
  theta = list(R0 = c(2.5, 3, 0.5), gamma = 1, lambda = 1, shape = 1),
  change_day = c(2,3),
  iota_dist = "exponential", # "weibull"
  gener = FALSE, b = 1/2,
  E0 = 0, type = "SIR" # "SEIR"
) {

  #
  # Population

  N0 <- S0 + I0


  #
  # Parameters

  theta <- complete_theta(theta, iota_dist, S0)

  beta    <- theta[["beta"   ]] # revised: vector.
  gamma   <- theta[["gamma"  ]]
  lambda  <- theta[["lambda" ]]
  shape   <- theta[["shape"  ]]
  epsilon <- theta[["epsilon"]]


  #
  # Initialization

  tau_T <- tau_F <- tau_J <- rep(Inf, N0)
  S <- E <- I <- t <- W <- X <- I_tau_t_true <- c() # S, E, I, R, time, waiting time, type of event, and number of infectious at infection times

  # Initialize tau's
  if(type == "SIR") {

    tau_T[1 : I0] <- 0 # TODO: relax assumption that individual initially infected at 0; important for non-Markovian process
    iotas <- simulate_iota(I0, iota_dist, gamma, shape, lambda) # time until recovery.
    tau_J[1 : I0] <- tau_T[1 : I0] + iotas

  } else if(type == "SEIR") {

    if(I0 > 0) {
      tau_T[1 : I0] <- -Inf
      tau_F[1 : I0] <- 0 # TODO: relax assumption
      iotas <- simulate_iota(I0, iota_dist, gamma, shape, lambda)
      tau_J[1 : I0] <- tau_F[1 : I0] + iotas
    } # end-if(I0)
    if(E0 > 0) {
      tau_T[I0 + (1 : E0)] <- 0
      epsilons <- rexp(E0, epsilon) # could not find rexp2
    #  epsilons <- stats::rexp(E0, epsilon)
      tau_F[I0 + (1 : E0)] <- tau_T[I0 + (1 : E0)] + epsilons
    } # end-if(E0)

  }# end-if(SIR)

  # Initialize compartments, time, event type and event number
  S[1] <- S0
  E[1] <- E0
  I[1] <- I0
  t[1] <- 0
  X[1] <- "no event"
  n_t  <- n_f <- n_j <- 0


  #
  # Simulation

  j <- 1 # iteration
  
  ### revised: SET INITIAL BETA TO beta[1].
  beta_curr <- beta[1]
  repeat{

    # Compute next removal time
    not_recovered <- tau_J > t[j]
    tau_J_next    <- min(tau_J[not_recovered])

    # Generate candidate infection time
    tau_T_candidate <- if(S[j] > 0) {
      
      ### revised: IF t[j] > CHANGE-POINT, beta_curr <- beta[i+1].
      for(i in 1:length(change_day)){
          if(t[j] >= change_day[i]){ # keep adjusting until you reach to change_day that t[j] is larger than.
            beta_curr <- beta[i+1]
          }
  
      }
      
      mu_j <- if(gener)  beta_curr * S[j]^(1 - b) * I[j]  else beta_curr * S[j] * I[j]
      t[j] + rexp(1, mu_j)            # candidate infection time (##propose infection time.##)
    } else if(S[j] == 0) {            # susceptible pop depleted
      Inf
    }

    # Event: removal or infection
    if(tau_T_candidate < tau_J_next) { # infection (SIR) / exposition (SEIR)

      I_tau_t_true <- c(I_tau_t_true, I[j]) # sanity check for f_log()

      n_t <- n_t + 1
      X[j + 1] <- "t"
      t[j + 1] <- tau_T_candidate
      S[j + 1] <- S[j] - 1
      if(type == "SEIR") {
        E[j + 1] <- E[j] + 1
        I[j + 1] <- I[j]
        #tau_T[n_t] <- tau_T_candidate # check index
      } else if(type == "SIR") {
        I[j + 1] <- I[j] + 1
        tau_T[I0 + n_t] <- tau_T_candidate
      }

      # simulate removal time of newly infected
      iota <- simulate_iota(1, iota_dist, gamma, shape, lambda)

      tau_J[I0 + n_t] <- tau_T[I0 + n_t] + iota

    } else if(tau_J_next <= tau_T_candidate) { # removal

      n_j <- n_j + 1
      X[j + 1] <- "j"
      t[j + 1] <- tau_J_next
      S[j + 1] <- S[j]
      if(type == "SEIR")  E[j + 1] <- E[j]
      I[j + 1] <- I[j] - 1

      if(I[j + 1] == 0)  break # infectious population depleted
      #TODO: if SEIR, also need to have E[j + 1]] == 0

    } # end-if

    j <- j + 1

  } # end-repeat


  # Events observed before t_end
  t_obs             <- t <= t_end
  tau_T_obs         <- tau_T <= t_end
  tau_J_obs         <- tau_J <= t_end
  tau_F_obs         <- tau_F <= t_end
  tau_T[!tau_T_obs] <- Inf
  tau_J[!tau_J_obs] <- Inf
  tau_F[!tau_F_obs] <- Inf
  
  ### (IN ORDER TO COMPUTE MLE) EVENT TIMES DIVIDED INTO CURRENT BETA SEGMENTS
  #t_obs_1             <- t <= change_day
  #tau_T_obs_1         <- tau_T <= change_day
  #tau_J_obs_1         <- tau_J <= change_day
  #tau_F_obs_1         <- tau_F <= change_day
  #tau_T[!tau_T_obs] <- Inf
  #tau_J[!tau_J_obs] <- Inf
  #tau_F[!tau_F_obs] <- Inf

  x <- list(
    compatible = TRUE, tau_T = tau_T, tau_J = tau_J, tau_F = tau_F
  )

  # MLE
  n_t_obs    <- sum(0 < tau_T & is.finite(tau_T))
  n_j_obs    <- sum(is.finite(tau_J))

  dt              <- diff(c(t[t_obs], t_end))
  integral_I_obs  <- sum(I[t_obs] * dt)
  integral_SI_obs <- if(gener) {
    sum(I[t_obs] * S[t_obs]^(1 - b) * dt)
  } else{
    sum(I[t_obs] * S[t_obs]         * dt)
  }

  # COMPUTE FOR EACH BETA: beta_i_MLE <- n_t_obs / integral_SI_obs
  
  beta_MLE   <- n_t_obs / integral_SI_obs
  gamma_MLE  <- n_j_obs / integral_I_obs
  R0_MLE     <- S0 * beta_MLE / gamma_MLE


  # Output
  out <- list(
    x = x, t = t, X = X, S = S, E = E, I = I, t_end = t_end, I0 = I0, S0 = S0,
    MLE = c("beta" = beta_MLE, "gamma" = gamma_MLE, "R0" = R0_MLE),
    SS = c("n_t" = n_t_obs, "n_j" = n_j_obs, "integral_SI" = integral_SI_obs, "integral_I" = integral_I_obs)
  )

  if(iota_dist == "weibull") {

    lambda_MLE <- n_j_obs / sum( (pmin(tau_J, t_end) - tau_T)[is.finite(tau_T)]^shape )
    out[["MLE"]][["lambda"]] <- lambda_MLE

    # shape_MLE <- optimize(
    # nu_posterior,
    # interval = c(0.01, 1e1),
    # theta = theta_true, SS = SS_true,
    # maximum = TRUE
    # )[["maximum"]]
    # TODO: run optim(), with true values as initial values to obtain MLE

  }

  return(out)

}
```


# Original version without change points in beta
```{r}
simulate_SEM <- function(
  S0 = 1e3, I0 = 1e1, t_end = 6,
  theta = list(R0 = 2.5, gamma = 1, lambda = 1, shape = 1),
  iota_dist = "exponential", # "weibull"
  gener = FALSE, b = 1/2,
  E0 = 0, type = "SIR" # "SEIR"
)
#data
```

```{r}
plot(x = data$t, y = data$S)
plot(x = data$t, y = data$I)
plot(x = data$t, y = data$R)
```

# change points in beta on days 1,3
```{r}
change_point_data <- simulate_change_point_SEM(
  S0 = 1e3, I0 = 1e1, t_end = 6,
  theta = list(R0 = c(2.5, 1, 1.5), gamma = 1, lambda = 1, shape = 1),
  change_day = c(1,3),
  iota_dist = "exponential", # "weibull"
  gener = FALSE, b = 1/2,
  E0 = 0, type = "SIR" # "SEIR"
)
#change_point_data
```

```{r}
plot(x = change_point_data$t, y = change_point_data$S)
plot(x = change_point_data$t, y = change_point_data$I)
plot(x = change_point_data$t, y = change_point_data$R)
```
Helper functions:
```{r}
#' Include beta to the parameter vector theta
#'
#' @param theta parameters (without beta)
#' @param S0 initial population size
#'
#' @return theta including beta
#' @export
#'

add_beta <- function(theta, S0) {

  gamma <- theta[["gamma"]]
  R0    <- theta[["R0"   ]]

  theta[["beta"]] <- R0 * gamma / S0 #if R0 is a vector, beta is a vector.

  return(theta)

}

add_gamma <- function(theta) {

  lambda <- theta[["lambda"]]
  shape  <- theta[["shape" ]]

  theta[["gamma"]] <- 1 / (lambda ^ (- 1 / shape) * gamma(1 + 1 / shape))

  return(theta)

}

complete_theta <- function(theta, iota_dist, S0) {

  if(iota_dist == "exponential") theta[c("shape", "lambda")] <- NULL
  if(iota_dist == "weibull")     theta <- add_gamma(theta)
  theta <- add_beta(theta, S0) # theta[["beta"]] will be c(b1, b2)

  return(theta)

}
```


```{r}
S0 = 1e3
I0 = 1e1
t_end = 6

theta = list(R0 = c(2.5,1.9, 0), gamma = 1, lambda = 1, shape = 1)
```

Here, we take in a vector of R0 and create a vector of Betas.
```{r}
vector_of_beta <- add_beta(theta, S0)
vector_of_beta
```
